# Melhores Práticas com o Jitterbit Harmony

[//]: # (This is a translation of Version 51, published on June 17, 2022.)

## Introdução

Este documento serve como guia geral para usar o Jitterbit Harmony. Ele dá orientações sobre as melhores práticas para cenários de integração comuns e recomendações sobre o uso das ferramentas disponíveis. Este documento não é totalmente abrangente e não inclui todos os cenários.

Este documento é para usuários do [Jitterbit Harmony Cloud Studio](https://success.jitterbit.com/display/CS/Cloud+Studio?showLanguage=pt_BR), a versão baseada na web da aplicação de *design* de projetos da Jitterbit. Para conhecer as melhores práticas de uso do [Design Studio](https://success.jitterbit.com/display/DOC/Design+Studio?showLanguage=pt_BR), a aplicação de *design* de projetos para *desktops* da Jitterbit, veja o artigo [Melhores Práticas com o Design Studio](https://success.jitterbit.com/display/DOC/Best+Practices+with+Design+Studio?showLanguage=pt_BR).

Antes de usar este guia, você já deve estar familiarizado(a) com o Jitterbit Harmony e com o Cloud Studio. Caso você não esteja, poderá fazer isso das seguintes formas:

-   Complete o [Manual Rápido para Administradores Jitterbit](https://success.jitterbit.com/display/DOC/Jitterbit+Admin+Quick+Start+Tutorial?showLanguage=pt_BR).

-   Matricule-se e faça cursos relacionados na [Jitterbit University](https://success.jitterbit.com/display/DOC/Getting+Training?showLanguage=pt_BR), como por exemplo, [Introdução ao Jitterbit Harmony Cloud Studio](https://success.jitterbit.com/display/DOC/Introduction+to+the+Jitterbit+Harmony+Cloud+Studio?showLanguage=pt_BR) e [Introdução ao Uso de *Scripts* no Cloud Studio](https://success.jitterbit.com/display/DOC/Introduction+to+Scripting+in+Cloud+Studio?showLanguage=pt_BR).

Depois disso, você conhecerá os conceitos e termos básicos usados no Jitterbit Harmony e será capaz de entender o que queremos dizer quando falamos sobre *projetos*, *operações*, *endpoints*, *scripts*, *migração* e *implantação*.


## Usando o Suporte, os CSMs e a Documentação

O acesso ao Jitterbit Support (Suporte Jitterbit) é incluído como parte da sua licença de cliente do Jitterbit Harmony. Quando surgirem dúvidas ou dificuldades técnicas, você pode receber assistência especializada do Jitterbit Support por meio do [portal](https://community.jitterbit.com/s/login/?startURL=%2Fs%2Fsupport) ou através de um [e-mail](mailto:support@jitterbit.com). O artigo [Como Receber Ajuda](https://success.jitterbit.com/display/DOC/Getting+Support?showLanguage=pt_BR) dá instruções especiais para que você saiba o que fazer em casos emergenciais nos quais a sua produção foi interrompida para que temas urgentes sejam atendidos mais rápido.

Você também pode entrar em contato com o(a) seu(sua) [Gerente de Sucesso do Cliente](mailto:success@jitterbit.com) (CSM, sigla em inglês) para esclarecer as suas dúvidas sobre a sua licença ou sobre outros tópicos.

Este site de documentação ([Jitterbit Success Central](https://success.jitterbit.com/)) e o nosso site de documentação para desenvolvedores ([Jitterbit Developer Portal](https://developer.jitterbit.com/)) contêm mais de 1400 páginas de material técnico.

Para ajudar você a localizar o material mais relevante para você, cada tópico principal na Success Central tem uma barra de pesquisa que pode ser usada para encontrar páginas somente dentro daquele tópico. Por exemplo, na página do tópico [Cloud Studio](https://success.jitterbit.com/display/CS/Cloud+Studio?showLanguage=pt_BR), você pode buscar um termo como *Condição* (ilustrado em inglês na imagem abaixo) para que sejam retornadas apenas páginas dentro da seção do Cloud Studio da documentação, sem a inclusão de materiais similares relacionados ao mesmo tópico no Design Studio:

<span class="confluence-embedded-file-wrapper"><img src="https://success.jitterbit.com/download/attachments/60818003/image2022-6-16_21-6-4.png?version=1&modificationDate=1655435164405&api=v2" class="confluence-embedded-image confluence-external-resource" data-image-src="https://success.jitterbit.com/download/attachments/60818003/image2022-6-16_21-6-4.png?version=1&modificationDate=1655435164405&api=v2" /></span>


## Atualizações de Produtos Jitterbit

Atualizações do Jitterbit Harmony são lançadas frequentemente (veja a [Agenda de Lançamentos](https://success.jitterbit.com/display/DOC/Release+Schedule?showLanguage=pt_BR)). Até mesmo lançamentos pequenos contêm novos recursos e melhorias além de consertos pontuais.

As aplicações em nuvem acessadas por meio do [Jitterbit Harmony Portal](https://success.jitterbit.com/display/DOC/Jitterbit+Harmony+Portal?showLanguage=pt_BR) são atualizadas automaticamente e portanto sempre estão executando a versão lançada há menos tempo. Tais aplicações incluem o [Cloud Studio](https://success.jitterbit.com/display/CS/Cloud+Studio?showLanguage=pt_BR), o [API Manager](https://success.jitterbit.com/display/DOC/API+Manager?showLanguage=pt_BR), o [App Builder](https://success.jitterbit.com/display/APP/App+Builder?showLanguage=pt_BR), o [Marketplace](https://success.jitterbit.com/display/DOC/Marketplace?showLanguage=pt_BR), o [Management Console](https://success.jitterbit.com/display/DOC/Management+Console?showLanguage=pt_BR) e o [Citizen Integrator](https://success.jitterbit.com/display/DOC/Citizen+Integrator?showLanguage=pt_BR).

Atualizações no [Cloud API Gateway](https://success.jitterbit.com/display/DOC/Cloud+API+Gateway?showLanguage=pt_BR) e no [Cloud Agent Group](https://success.jitterbit.com/display/DOC/Cloud+Agent+Groups?showLanguage=pt_BR) são aplicadas automaticamente. Para os Cloud Agents Groups, existem dois conjuntos: Production e Sandbox. Este segundo é usado para testar a compatibilidade com pré-lançamentos de *softwares* de agente e ***não*** é um ambiente de desenvolvimento.

Aplicações instaladas localmente são atualizadas mediante o download e execução de um instalador:

-   Atualizações de [Private Agent](https://success.jitterbit.com/display/DOC/Private+Agents?showLanguage=pt_BR) são aplicadas manualmente usando o instalador. Instruções de atualização específicas para cada sistema operacional suportado são dadas nas [instruções de instalação de Private Agents](https://success.jitterbit.com/display/DOC/Private+Agent+Installation?showLanguage=pt_BR).

-   Atualizações de [Private API Gateway](https://success.jitterbit.com/display/DOC/Private+API+Gateway?showLanguage=pt_BR) são aplicadas manualmente usando o instalador. Instruções detalhadas são dadas nas [instruções de instalação de Private API Gateways](https://success.jitterbit.com/display/DOC/Installing+a+Private+API+Gateway?showLanguage=pt_BR).

-   Para o [Design Studio](https://success.jitterbit.com/display/DOC/Design+Studio?showLanguage=pt_BR), o processo para atualizar consiste de realizar uma nova instalação. Várias versões distintas do Design Studio podem coexistir numa mesma máquina e compartilhar o mesmo grupo de projetos.

É muito aconselhável manter-se atualizado com os lançamentos mais recentes, especialmente aqueles que incluem melhorias de recursos.


## *Design* de Projetos e Reusabilidade

Um cenário típico para reusar um projeto envolve o desenvolvimento de um projeto *inicial* com uso extensivo de [variáveis globais](https://success.jitterbit.com/display/CS/Global+Variables?showLanguage=pt_BR) e, principalmente, de [variáveis de projeto](https://success.jitterbit.com/display/CS/Project+Variables?showLanguage=pt_BR). Itens configuráveis - como credenciais de *endpoints*, mapeamentos de campos opcionais, *queries* com parâmetros, endereços de e-mail e nomes de arquivos - podem ser expostos como variáveis de projetos. O projeto inicial também pode conter funções comuns como tratamento de erros ou o uso de *caches* que abarcam o ambiente todo. O projeto inicial é exportado e daí importado para novos projetos para formar uma base consistente para o desenvolvimento.

### Reuso de *Endpoints*

Os *endpoints*, criados através da configuração de uma conexão e de suas atividades associadas usando [conectores](https://success.jitterbit.com/display/CS/Connectors?showLanguage=pt_BR), são muito usados em operações. No entanto, um *endpoint* único não precisa necessariamente ser construído para cada operação. Já que as configurações de atividade aceitam variáveis para caminhos e nomes de arquivos, *endpoints* genéricos podem ser construídos uma vez e daí configurados dinamicamente com o uso de variáveis globais e de projeto.

Por exemplo, imagine que uma conexão [HTTP](https://success.jitterbit.com/display/CS/HTTP?showLanguage=pt_BR) e uma atividade associada são criadas, e que a configuração da atividade especifica um caminho definido por uma variável global, como `$gv_http_path`. Um *script* pode ser usado para preencher o caminho `$gv_http_path` conforme a necessidade.

Outro exemplo é uma atividade Database **Query** que tenha uma condição. A condição, iniciada por `WHERE`, pode ser atribuída a uma variável global, como `$gv_database_condition`.

A maioria dos endpoints têm a capacidade de serem configurados usando variáveis.

### Reuso de *Scripts*

[*Scripts*](https://success.jitterbit.com/display/CS/Scripts?showLanguage=pt_BR) soltos que realizam uma função específica, como retornar o resultado de uma consulta em banco de dados ou calcular um resultado a partir de uma série de argumentos, também são candidatos para reuso, principalmente se são usados em várias operações.

Por exemplo, se um *script* usa a função [`DBLookup`](https://success.jitterbit.com/display/CS/Database+Functions#heading-DBLookup) em uma tabela de banco de dados, e esta função é usada ao longo de todo um projeto, então um *script* solto (separado de uma operação) pode ser construído. Usando a função [ArgumentList](https://success.jitterbit.com/display/CS/General+Functions#GeneralFunctions-ArgumentList) ou variáveis globais simples, o *script* pode aceitar argumentos e retornar um resultado. Já que toda cadeia de operação é um escopo diferente, o mesmo *script* pode ser chamado com segurança a partir de várias operações simultâneas.


## Organização de Projetos

Os [workflows](https://success.jitterbit.com/display/CS/Workflows?showLanguage=pt_BR) são usados como forma de organização de projeto. Um workflow normalmente contém operações relacionadas que processam dados do início ao fim: *Create Orders* (Criar Pedidos), *Sync Customer Master* (Sincronizar *Customer Master*), *Process Confirmations* (Confirmações de Processo), etc. Processos que são comuns em diferentes workflows, como fazer um *query* em um *endpoint* ou tratar uma condição de erro de operação podem estar contidos em seus próprios workflows e ser referenciados por outras operações de workflow.

Você também pode criar [grupos customizados](https://success.jitterbit.com/display/CS/Component+Groups?showLanguage=pt_BR) nos quais componentes de projeto podem ser agrupados para facilitar as referências.

Os números atribuídos às operações que aparecem no *designer* de projeto são atribuídos automaticamente e são baseados na posição de exibição da operação no *designer* de projeto. Estes números não são mostrados nos [registros de operação](https://success.jitterbit.com/display/CS/Operation+Logs?showLanguage=pt_BR). Se um padrão de numeração de operação for necessário, ele pode ser implementado ao se incorporar a numeração no nome da operação.

### Gerenciando Operações Assíncronas

Ao se usar a função [RunOperation](https://success.jitterbit.com/display/CS/General+Functions#GeneralFunctions-RunOperation) em seu modo assíncrono, as operações executam sem devolver o controle à função que fez a chamada. O uso de operações assíncronas pode levar a condições de corrida.

Por exemplo, se a *Operação A* atualizar uma tabela de banco de dados e for conectada à *Operação B*, que lê a mesma tabela (ambas são síncronas), nenhuma condição de corrida ocorre. Mas se a *Operação A* for chamada de forma assíncrona e imediatamente depois a *Operação B* também for chamada, é possível que a B execute antes que a A tenha terminado.

Além disso, o número de chamadas assíncronas simultâneas precisa ser gerenciado, já que o número de operações simultâneas em execução em um mesmo agente é limitado (veja a seção <a href="https://success.jitterbit.com/display/DOC/Editing+the+Configuration+File+-+jitterbit.conf#EditingtheConfigurationFilejitterbit.conf-operation-engine">`\[OperationEngine\]`</a> do [arquivo de configuração do Private Agent](https://success.jitterbit.com/display/DOC/Editing+the+Configuration+File+-+jitterbit.conf)).

### Credenciais de *Endpoints*

Nós recomendamos que você use um ID de sistema com permissões de administração como credenciais de *endpoint* em vez de usar um ID de nível de usuário. Os IDs de usuário normalmente expiram ou precisam ser desabilitados quando o(a) usuário(a) deixa a empresa.

Por usar variáveis de projeto (cujos valores podem ser escondidos) para o gerenciamento de credenciais, o(a) administrador(a) de uma organização Harmony não precisa inserir credenciais de produção. Por configurar permissões de usuário apropriadas, um(a) usuário(a) pode aplicar as credenciais de produção por meio da página [Projetos](https://success.jitterbit.com/display/DOC/Projects?showLanguage=pt_BR) do Management Console.

Se você estiver usando Private Agents, como alternativa ao uso do Management Console, variáveis globais podem ser gerenciadas por meio do uso da seção <a href="https://success.jitterbit.com/display/DOC/Editing+the+Configuration+File+-+jitterbit.conf#EditingtheConfigurationFilejitterbit.conf-predefinedglobalvariables">`\[PredefinedGlobalVariables\]`</a> do [arquivo de configuração do Private Agent](https://success.jitterbit.com/display/DOC/Editing+the+Configuration+File+-+jitterbit.conf).


## Dados de Integração Persistentes

Existem vários métodos para armazenar dados na nuvem do Harmony, incluindo o uso de variáveis de projeto, funções de *caching* em nuvem ou armazenamento temporário.

### Variáveis de Projeto

Variáveis de projeto são variáveis estáticas pré-inicializadas que podem ser entendidas como constantes de projeto. Elas podem ser editadas no Cloud Studio (veja o artigo [Variáveis de Projeto](https://success.jitterbit.com/display/CS/Project+Variables?showLanguage=pt_BR)) ou no Management Console (veja o artigo [Projetos](https://success.jitterbit.com/display/DOC/Projects?showLanguage=pt_BR)).

Um uso exemplo de variáveis de projeto é para credenciais de *endpoints*. Por usar variáveis de projeto, diferentes ambientes de *endpoints* (que normalmente têm credenciais diferentes) podem ser aplicados a diferentes [ambientes](https://success.jitterbit.com/display/DOC/Environments?showLanguage=pt_BR) do Harmony e editados por meio do Management Console. Isto possibilita um processo de negócio em que um usuário com direitos de Management Console possa mudar credenciais sem requerer acesso ao Design Studio e ao *designer* de projeto.

Um segundo exemplo é usar variáveis de projeto para segurar sinalizadores usados pela lógica de integração que podem customizar o comportamento da integração. Se um único projeto for desenvolvido mas for usado para *endpoints* diferentes, então uma variável de projeto booleana (como *Send_PO_Number*) pode ser verificada pela lógica do *transformation* para obter o campo *PO Number*. Se o valor da variável de projeto for falso, então a função <a href="https://success.jitterbit.com/display/CS/Database+Functions#DatabaseFunctions-Unmap">`UnMap`</a> poderia ser usada para “desligar” tal campo e não incluí-lo no *transformation* relevante.

### Funções de *Caching* em Nuvem

As funções de *caching* em nuvem <a href="https://success.jitterbit.com/display/CS/Cache+Functions#CacheFunctions-ReadCache">`ReadCache`</a> e <a href="https://success.jitterbit.com/display/CS/Cache+Functions#CacheFunctions-WriteCache">`WriteCache`</a> são usadas para atribuir espaços de dados que ficam disponíveis em vários projetos e ambientes. Um valor *cached* está visível para todas as operações sendo executadas no mesmo escopo até expirar, independentemente de como essa operação foi iniciada ou de em qual agente ela executa. Por fazer o *caching* de dados no Jitterbit Harmony, em vez de depender de armazenamentos de dados locais ou específicos a um agente como o [conector Temporary Storage](https://success.jitterbit.com/display/CS/Temporary+Storage?showLanguage=pt_BR), os dados podem ser compartilhados entre operações separadas e em vários projetos.

Usos adicionais do *caching* em nuvem incluem:

-   Dados podem ser compartilhados entre operações assíncronas dentro de um projeto.
-   Erros que são gerados em diferentes operações podem ser armazenados num *cache* comum. Por usar isso para acumular resultados de operação, alertas mais abrangentes podem ser construídos.
-   *Tokens* de *login* podem ser compartilhados entre várias operações.

### Administrando Armazenamento Temporário

Os *endpoints* [Temporary Storage](https://success.jitterbit.com/display/CS/Temporary+Storage?showLanguage=pt_BR) (Armazenamento Temporário) são frequentemente usados em operações tanto com Cloud Agents quanto com Private Agents. Isso é diferente dos *endpoints* [Local Storage](https://success.jitterbit.com/display/CS/Local+Storage?showLanguage=pt_BR) (Armazenamento Local), que podem ser usados apenas com Private Agents.

Ao usar um *endpoint* Temporary Storage, arquivos temporários são usados para leituras e gravações no diretório temporário do sistema operacional padrão do agente que está realizando o trabalho:

-   No caso de um único Private Agent, o diretório de armazenamento temporário é o diretório temporário padrão do servidor daquele Private Agent.
-   Se você estiver usando mais de um Private Agent, agrupado em um Private Agent Group, o diretório de armazenamento temporário é o diretório temporário padrão do *servidor de Private Agent específico* realizando o trabalho.
-   Visto que os Cloud Agents ficam agrupados em um Cloud Agent Group, o diretório de armazenamento temporário é o diretório temporário padrão do *servidor de Cloud Agent específico* realizando o trabalho.

Em um Agent Group (seja este de Private Agents ou Cloud Agents), desde que as operações usando o armazenamento temporário estejam conectadas (encadeadas), então todas as leituras e gravações de armazenamento temporário acontecerão no mesmo servidor de agente. No entanto, se a *Cadeia A* grava em seu próprio arquivo de armazenamento temporário chamado `myfile` e a *Cadeia B* lê do seu próprio arquivo de armazenamento temporário chamado `myfile`, e as duas cadeias não estiverem conectadas uma à outra, a ação de leitura do armazenamento temporário na *Cadeia B* pode não ler do mesmo agente que a *Cadeia A*.

Ao usar o armazenamento temporário, mantenha as seguintes diretrizes em mente:

-   Ao usar Private Agents, para tornar o seu projeto “à prova de atualizações”, use o armazenamento temporário de tal forma que fazer a mudança de um único Private Agent para um Agent Group com vários agentes não exija refatoramento.
-   Ao usar um Agent Group (seja este de Private Agents ou Cloud Agents), para garantir que o servidor de agente onde o armazenamento temporário é gravado seja o mesmo servidor de onde o armazenamento temporário será lido, tenha certeza de que quaisquer referências às atividades *Read* (Ler) e *Write* (Gravar) no armazenamento temporário estejam na mesma cadeia de operações.
-   Por padrão, o armazenamento temporário em Private Agents é deletado após 24 horas por um [serviço de limpeza da Jitterbit](https://success.jitterbit.com/display/DOC/Editing+the+Jitterbit+File+Cleanup+Service+Rules+for+Private+Agents?showLanguage=pt_BR). A frequência do serviço de limpeza pode ser configurada por meio do [arquivo de configuração de Private Agents](https://success.jitterbit.com/display/DOC/Editing+the+Configuration+File+-+jitterbit.conf), na seção `\[FileCleanup\]`. No entanto, nos Cloud Agents, os arquivos temporários podem ser deletados imediatamente.
-   Os Cloud Agents têm um limite de tamanho para arquivos de armazenamento temporário de 50 GB por arquivo. Arquivos temporários com mais de 50 GB só são possíveis com o uso de Private Agents.
-   Ao se gravar em um armazenamento temporário, o padrão é sobrescrever arquivos. Isso pode ser alterado com a caixa de seleção chamada **Append to File** (Adicionar ao Arquivo) da atividade [Temporary Storage Write](https://success.jitterbit.com/display/CS/Temporary+Storage+Write+Activity?showLanguage=pt_BR). Normalmente, isto requer então que depois que a fonte seja lida, que o arquivo seja deletado ou arquivado. Uma forma simples de fazer isso é usando as opções de pós-processamento chamadas **Delete File** (Deletar Arquivo) ou **Rename File** (Renomear Arquivo) da atividade [Temporary Storage Read](https://success.jitterbit.com/display/CS/Temporary+Storage+Read+Activity?showLanguage=pt_BR).
-   Existem algumas [palavras-chave de nomes de arquivos](https://success.jitterbit.com/display/DOC/Filename+Keywords?showLanguage=pt_BR) disponíveis que podem ser usadas ao criar um nome de arquivo.
-   Um arquivo num armazenamento temporário pode ser lido construindo-se um script com a função <a href="https://success.jitterbit.com/display/CS/File+Functions#FileFunctions-ReadFile">`ReadFile`</a>. Por exemplo `ReadFile(“<TAG>activity:tempstorage/Temporary Storage/tempstorage_read/Read</TAG>”)`. Tenha em mente que isto só funciona confiavelmente se só houver um único Private Agent.

Em alguns casos, pode ser vantajoso usar um *endpoint* [Variable](https://success.jitterbit.com/display/CS/Variable?showLanguage=pt_BR) em vez de um *endpoint* Temporary Storage. Veja o artigo [Variável Global contra Armazenamento Temporário](https://success.jitterbit.com/display/DOC/Global+Variable+versus+Temporary+Storage?showLanguage=pt_BR) para ver uma comparação completa desses dois tipos diferentes, bem como recomendações sobre quando cada um é melhor.


## Uso de *Scripts*

Scripts escritos na linguagem [Jitterbit Script](https://success.jitterbit.com/display/CS/Jitterbit+Script?showLanguage=pt_BR) ou em [JavaScript](https://success.jitterbit.com/display/CS/JavaScript?showLanguage=pt_BR) podem ser usados em quase qualquer lugar das operações e dentro dos mapeamentos de *transformations*.

### Quando Usar *Scripts*

As operações podem ser organizadas em cadeias de operação de duas formas: (1) ao se conectar (encadear) operações usando condições **On Success** (Em Caso de Sucesso) e **On Fail** (Em Caso de Falha) usando [ações de operação](https://success.jitterbit.com/display/CS/Operation+Actions?showLanguage=pt_BR) ou (2) usando um *[script](https://success.jitterbit.com/display/CS/Scripts?showLanguage=pt_BR) controlador*.

Em vez de usar ações de operação, um *script* controlador usa a função <a href="https://success.jitterbit.com/display/CS/General+Functions#GeneralFunctions-RunOperation">`RunOperation`</a> para encadear operações usando um *script*.

Para capturar uma operação que falhou, a função <a href="https://success.jitterbit.com/display/CS/Logical+Functions#LogicalFunctions-If">`If`</a> pode ser usada em conjunto com `RunOperation`. Por exemplo: `If(!RunOperation(<operation tag>), <condition>`), onde a `condition` (condição) pode usar a função <a href="https://success.jitterbit.com/display/CS/Logging+and+Error+Functions#LoggingandErrorFunctions-GetLastError">`GetLastError`</a> para capturar o erro, e pode também deter o processo inteiro usando a função <a href="https://success.jitterbit.com/display/CS/Logging+and+Error+Functions#LoggingandErrorFunctions-RaiseError">`RaiseError`</a>, e/ou executar outro processo para acumular texto de erro.

Um *script* controlador pode ser benéfico em situações como as seguintes:

-   Para executar uma operação que é dependente de fatores externos como variáveis de projeto ou dados.
-   Para chamar sub-operações de dentro de um laço (*loop*), onde os dados são passados para a operação a partir de uma lista.
-   Para traçar atividades de cadeias de operação. Por exemplo: `(WriteToOperationLog(“count of records to process: ” + cnt)`, `WriteToOperationLog(“Starting update operation at: ” + Now())`, `WriteToOperationLog(“Database query: ” + sql)`, etc.

Outras áreas nas quais *scripts* são frequentemente usadas incluem campos mapeados dentro de *transformations* e também dentro de outros *scripts*. Se o mesmo *script* estiver sendo usado dentro de mais de um *transformation*, cogite a possibilidade de configurá-lo como um *script* solto e chamá-lo de cada um dos *transformations* usando a função <a href="https://success.jitterbit.com/display/CS/General+Functions#GeneralFunctions-RunScript">`RunScript`</a>.

### Convenção de Nomenclatura para Variáveis

O Harmony tem quatro tipos de variáveis:

-   [Variáveis locais](https://success.jitterbit.com/display/CS/Local+Variables?showLanguage=pt_BR): Definidas e acessadas em um único [Jitterbit Script](https://success.jitterbit.com/display/CS/Jitterbit+Script?showLanguage=pt_BR) ou [JavaScript](https://success.jitterbit.com/display/CS/JavaScript?showLanguage=pt_BR).
-   [Variáveis globais](https://success.jitterbit.com/display/CS/Global+Variables?showLanguage=pt_BR): Definidas em um [Jitterbit Script](https://success.jitterbit.com/display/CS/Jitterbit+Script?showLanguage=pt_BR) ou [JavaScript](https://success.jitterbit.com/display/CS/JavaScript?showLanguage=pt_BR) e disponíveis por todo o projeto.
-   [Variáveis de projeto](https://success.jitterbit.com/display/CS/Project+Variables?showLanguage=pt_BR): Definidas na interface de usuário do Cloud Studio e disponíveis por todo o projeto. Atualizáveis por meio do Management Console.
-   [Variáveis Jitterbit](https://success.jitterbit.com/display/CS/Jitterbit+Variables?showLanguage=pt_BR): Pré-definidas no Jitterbit Harmony ou definidas no arquivo de configuração do Private Agent. Disponíveis por todo o projeto.

Como o escopo de uma variável local é limitado a um único *script*, uma convenção de nomenclatura para elas pode ser muito simples, como por exemplo usar apenas letras minúsculas ou uma palavra inicial, como `retorno` ou `minhaVariavel`. Pontos finais não são permitidos em variáveis locais.

No caso das variáveis globais, como o escopo delas é maior (uma variável global está disponível para ser referenciada na mesma operação ou *script*, ou naqueles abaixo deles na cadeia de operações), elas devem usar uma convenção de nomenclatura consistente para evitar confusões. Por exemplo, usando vários componentes para um nome de variável, separado por pontos finais, você poderia seguir um padrão tal como:

`tipo.categoria.subcategoria`

<div class="table-wrap">

<table class="wrapped confluenceTable">
<tbody>
<tr class="odd">
<td class="highlight-grey confluenceTd"
data-highlight-colour="grey"><p><strong>Componente</strong></p></td>
<td class="highlight-grey confluenceTd"
data-highlight-colour="grey"><p><strong>Descrição</strong></p></td>
</tr>
<tr class="even">
<td class="confluenceTd"><code>tipo</code></td>
<td class="confluenceTd"><p>Uma curta abreviação que identifica o tipo de variável, como <code>vp</code> (variável de projeto), <code>vg</code> (variável global), <code>io</code> (nome do <em>endpoint</em> fonte/alvo), <code>dict</code> (dicionário), etc.</p></td>
</tr>
<tr class="odd">
<td class="confluenceTd"><code>categoria</code></td>
<td class="confluenceTd"><p>Uma categoria lógica para a variável, como <code>sfdc</code>, <code>envio</code>, <code>confirmacao</code>, <code>pedido</code>, etc.</p></td>
</tr>
<tr class="even">
<td class="confluenceTd"><code>subcategoria</code></td>
<td
class="confluenceTd"><p>Uma subcategoria lógica para a variável, tal como <code>pedidos_da_compra</code>, <code>categorias</code>, <code>ids</code>, etc.</p></td>
</tr>
</tbody>
</table>

</div>

Ao combinar tais componentes, surgem os possíveis nomes de variáveis:

-   `$vp_shopify_base_url`
-   `$dict_staples_po_line_itens`
-   `$io_pedido`
-   `$vg_sfdc_ordem_de_trabalho_id`

Já que as variáveis são organizadas alfabeticamente em vários lugares por toda a interface de usuário, organizá-los hierarquicamente ajudará com o gerenciamento e uso das variáveis.

Independentemente da convenção que você decidir usar, nós recomendamos que você a codifique e documente para que todos os membros da equipe possam usá-la consistentemente em todos os projetos.

<div class="confluence-information-macro confluence-information-macro-information conf-macro output-block" data-hasbody="true" data-macro-name="info">

<span class="aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon"> </span>

<div class="confluence-information-macro-body">

<strong>NOTA:</strong> Se você estiver planejando usar variáveis globais <a href="https://success.jitterbit.com/display/CS/Jitterbit+Script?showLanguage=pt_BR">Jitterbit Script</a> em um script cuja linguagem principal é o <a href="https://success.jitterbit.com/display/CS/Jitterbit+Script?showLanguage=pt_BR">JavaScript</a>, é importante que você use underlines em vez de pontos:

-   `$exemplo_arr_nomes`
-   `$exemplo_sfdc_mensagem_de_sucesso`

</div>

</div>


## Ambientes

O Harmony torna possíveis metodologias de ciclo de vida de desenvolvimento de *software* por meio do uso de ambientes. Você pode preparar ambientes de produção e de não-produção.

Por exemplo, suponha que um ambiente *Development* (“desenvolvimento” em inglês) e um ambiente *Production* (“produção”) sejam preparados no Management Console e ambos sejam associados ao mesmo Agent Group. Suponha que um projeto é desenvolvido de início no ambiente *Development*.

O Cloud Studio tem um [recurso de migração](https://success.jitterbit.com/display/CS/Project+Migration?showLanguage=pt_BR) que vai copiar o projeto para o ambiente *Production*, e depois disso as credenciais do *endpoint* são alteradas para as credenciais do *endpoint* da *Production* usando [variáveis de projeto](https://success.jitterbit.com/display/CS/Project+Variables?showLanguage=pt_BR). Outros *endpoints* fonte e alvo também são alterados. Depois da migração inicial, qualquer migração futura do mesmo projeto do ambiente *Development* para o ambiente *Production* não migrará as variáveis de projeto a menos que sejam variáveis de projeto novas.


## Testes

O Harmony possibilita o desenvolvimento rápido de integrações e a testagem de unidades por tornar visíveis os dados de integração durante o tempo de *design*. A vantagem óbvia é habilitar um processo de desenvolvimento iterativo por mostrar os dados antes e depois das transformações dos campos, em vez de construir a operação inteira e executá-la para inspecionar as saídas depois. Os dados são tornados visíveis por meio do [recurso da pré-visualização](https://success.jitterbit.com/display/CS/Preview+Mode?showLanguage=pt_BR) em um *transformation*.

Depois que os dados fonte de amostra são importados ou gerados, o *transformation* mostrará a saída de quaisquer mapeamentos e *scripts* embutidos.


## Diagnóstico e Resolução de Problemas

Um conceito chave para uma arquitetura de integração saudável é reconhecer que haverá questões levantadas pelos negócios com relação à exatidão do trabalho de integração, principalmente quando aparecerem discrepâncias nos dados dos *endpoints*. Isso pode ou não ser culpa da integração. É responsabilidade do projeto de integração fornecer um alto grau de transparência de modo a ajudar a resolver questões sobre a exatidão dos dados.

Por exemplo, caso os dados em um *endpoint* alvo pareçam estar incorretos, então normalmente o suporte de integração é chamado para fornecer detalhes sobre as ações de integração, como horários, fontes, lógica dos *transformations*, mensagens de sucesso ou falha, etc. Tal processo de diagnóstico e resolução de problemas é beneficiado quando essas informações ficam disponíveis como parte normal da arquitetura de integração. No Harmony, isto é suportado por meio dos recursos de [registros](https://success.jitterbit.com/display/DOC/Jitterbit+Harmony+Best+Practices?showLanguage=pt_BR#heading-Registros) e [alertas](https://success.jitterbit.com/display/DOC/Jitterbit+Harmony+Best+Practices?showLanguage=pt_BR#heading-Alertas).

### Registros

Os registros de operação capturam dados chave por padrão, como os horários de execução da operação e mensagens de sucesso, falha ou cancelamento. Se houver falhas e o *endpoint* retornar informações sobre elas, o registro também as capturará.

Com relação às falhas, o Harmony usa a resposta para fazer a determinação do *status*. Por exemplo, se um código de *status* HTTP de 400 ou mais for recebido numa resposta, o Harmony considera isto uma falha. Se a solicitação tiver um *status* de 200 mas a resposta contiver erros de dados, o Harmony trata isso como um sucesso.

Ao desenvolver uma integração, use a função <a href="https://success.jitterbit.com/display/CS/Logging+and+Error+Functions#LoggingandErrorFunctions-WriteToOperationLog">`WriteToOperationLog()`</a> nos mapeamentos e nos *scripts* para capturar dados e etapas chave para o processo. Normalmente, fazer isso é bem simples: `WriteToOperationLog(“O id é: ”+sourcefieldid)`.

Se capturar a saída inteira de um *transformation* for desejado, isto pode ser feito construindo uma operação que lê a fonte, executa o *transformation* e grava as saídas em um *endpoint* [Variable](https://success.jitterbit.com/display/CS/Variable?showLanguage=pt_BR) ou [Temporary Storage](https://success.jitterbit.com/display/CS/Temporary+Storage?showLanguage=pt_BR) em vez do *endpoint* alvo. Um *script* de pós-operação pode então ler as saídas e registrá-las. Daí a operação “de verdade” pode ser executada.

Os registros podem ser visualizados na [tela de registros de operação](https://success.jitterbit.com/display/CS/Operation+Logs?showLanguage=pt_BR) do Cloud Studio ou na página [Atividades](https://success.jitterbit.com/display/DOC/Activities?showLanguage=pt_BR) do Management Console. A página [Atividades](https://success.jitterbit.com/display/DOC/Activities?showLanguage=pt_BR) do Management Console pode ser acessada pelo pessoal do suporte sem a necessidade de navegar até o projeto.

Os dados nos registros podem ser achados por buscas. Para filtrar apenas os registros que você precisa, você pode usar a sintaxe de busca <em>message=%<\seu texto aqui>%</em> nos registros tanto do Cloud Studio quanto do Management Console.

Muitas vezes, as APIs têm uma mensagem de sucesso ou não-sucesso que é bastante informativa. Se o registro de depuração estiver habilitado para a API, o corpo da resposta será capturado nos [registros de API](https://success.jitterbit.com/display/DOC/API+Logs?showLanguage=pt_BR) (que são separados dos registros de operação).

Os registros de operação, incluindo mensagens de registros detalhadas tanto dos Cloud Agents quanto dos Private Agents, são retidos por 30 dias pelo Jitterbit Harmony.

### Alertas

Frequentemente os resultados de integração não apenas precisam ser registrados, mas precisam também ser escalados. [Notificações de e-mail](https://success.jitterbit.com/display/CS/Email+Notifications?showLanguage=pt_BR) podem facilmente ser adicionadas às operações e aos caminhos de sucesso/falha ou chamadas por *scripts*. Uma outra opção é usar o conector [Email](https://success.jitterbit.com/display/CS/Email?showLanguage=pt_BR) para configurar uma atividade [Send Email](https://success.jitterbit.com/display/CS/Email+Send+Email+Activity?showLanguage=pt_BR) (“Enviar E-mail”) como alvo de uma operação.

Para informações adicionais, consulte o artigo [Como Preparar Alertas, Registros e Tratamento de Erros](https://success.jitterbit.com/display/DOC/Setting+Up+Alerting%2C+Logging%2C+and+Error+Handling?showLanguage=pt_BR).


## Recursos Adicionais

As seguintes seções e páginas da documentação falam sobre mais boas práticas.

### Tech Talks

Os [Jitterbit Tech Talks](https://success.jitterbit.com/display/DOC/Jitterbit+Tech+Talks?showLanguage=pt_BR) são apresentações de vídeo que abrangem áreas de interesse para usuários de todos os níveis:

<div class="table-wrap">

<table class="wrapped confluenceTable">
<tbody>
<tr class="odd">
<td class="highlight-grey confluenceTd"
data-highlight-colour="grey"><p><strong>Tech Talk</strong></p></td>
<td class="highlight-grey confluenceTd"
data-highlight-colour="grey"><p><strong>Duração</strong></p></td>
<td class="highlight-grey confluenceTd"
data-highlight-colour="grey"><p><strong>Data de Lançamento</strong></p></td>
</tr>
<tr class="even">
<td class="confluenceTd"><p><a href="https://success.jitterbit.com/display/DOC/Environments+Tech+Talk?showLanguage=pt_BR">Ambientes</a></p></td>
<td class="confluenceTd"><p>1:04:22</p></td>
<td class="confluenceTd"><p>04 de abril de 2018</p></td>
</tr>
<tr class="odd">
<td class="confluenceTd"><p><a href="https://success.jitterbit.com/display/DOC/API+Proxy+Tech+Talk?showLanguage=pt_BR">API Proxy</a></p></td>
<td class="confluenceTd"><p>39:53</p></td>
<td class="confluenceTd"><p>09 de janeiro de 2019</p></td>
</tr>
<tr class="even">
<td class="confluenceTd"><p><a href="https://success.jitterbit.com/display/DOC/APIs+Tech+Talk?showLanguage=pt_BR">APIs</a></p></td>
<td class="confluenceTd"><p>49:22</p></td>
<td class="confluenceTd"><p>07 de agosto de 2018</p></td>
</tr>
<tr class="odd">
<td class="confluenceTd"><p><a href="https://success.jitterbit.com/display/DOC/External+Credentials+Storage+and+Management+Tech+Talk?showLanguage=pt_BR">Armazenamento e Gerenciamento de Credenciais Externas</a></p></td>
<td class="confluenceTd"><p>46:58</p></td>
<td class="confluenceTd"><p>09 de outubro de 2020</p></td>
</tr>
<tr class="even">
<td class="confluenceTd"><p><a href="https://success.jitterbit.com/display/DOC/Cloud+Studio+Tech+Talk?showLanguage=pt_BR">Cloud Studio</a></p></td>
<td class="confluenceTd"><p>43:53</p></td>
<td class="confluenceTd"><p>14 de maio de 2019</p></td>
</tr>
<tr class="odd">
<td class="confluenceTd"><p><a href="https://success.jitterbit.com/display/DOC/Connector+Builder+Tech+Talk?showLanguage=pt_BR">Connector Builder</a></p></td>
<td class="confluenceTd"><p>50:19</p></td>
<td class="confluenceTd"><p>16 de julho de 2019</p></td>
</tr>
<tr class="even">
<td class="confluenceTd"><p><a href="https://success.jitterbit.com/display/DOC/Jitterbit+Best+Practices+Tech+Talk?showLanguage=pt_BR">Melhores Práticas com a Jitterbit</a></p></td>
<td class="confluenceTd"><p>1:04:38</p></td>
<td class="confluenceTd"><p>16 de março de 2020</p></td>
</tr>
<tr class="odd">
<td class="confluenceTd"><p><a href="https://success.jitterbit.com/display/DOC/Pass-Through+Sources+and+Global+Variables+Best+Practices+Tech+Talk?showLanguage=pt_BR">Melhores Práticas de Fontes de Passagem e Variáveis Globais</a></p></td>
<td class="confluenceTd"><p>42:44</p></td>
<td class="confluenceTd"><p>05 de dezembro de 2018</p></td>
</tr>
<tr class="even">
<td class="confluenceTd"><p><a href="https://success.jitterbit.com/display/DOC/Project+Organization+Best+Practices+Tech+Talk?showLanguage=pt_BR">Melhores Práticas de Organização de Projeto</a></p></td>
<td class="confluenceTd"><p>1:08:39</p></td>
<td class="confluenceTd"><p>08 de junho de 2018</p></td>
</tr>
<tr class="odd">
<td class="confluenceTd"><p><a href="https://success.jitterbit.com/display/DOC/Complex+Project+Orchestration+Best+Practices+Tech+Talk?showLanguage=pt_BR">Melhores Práticas de Orquestração de Projetos Complexos</a></p></td>
<td class="confluenceTd"><p>50:46</p></td>
<td class="confluenceTd"><p>16 de outubro de 2018</p></td>
</tr>
<tr class="even">
<td class="confluenceTd"><p><a href="https://success.jitterbit.com/display/DOC/Private+Agents+Best+Practices+Tech+Talk?showLanguage=pt_BR">Melhores Práticas de Private Agents</a></p></td>
<td class="confluenceTd"><p>42:43</p></td>
<td class="confluenceTd"><p>05 de julho de 2018</p></td>
</tr>
<tr class="odd">
<td class="confluenceTd"><p><a href="https://success.jitterbit.com/display/DOC/Logging+Best+Practices+Tech+Talk?showLanguage=pt_BR">Melhores Práticas de Registro</a></p></td>
<td class="confluenceTd"><p>1:03:02</p></td>
<td class="confluenceTd"><p>12 de fevereiro de 2019</p></td>
</tr>
<tr class="even">
<td class="confluenceTd"><p><a href="https://success.jitterbit.com/display/DOC/Error+Handling+Best+Practices+Tech+Talk?showLanguage=pt_BR">Melhores Práticas de Tratamento de Erros</a></p></td>
<td class="confluenceTd"><p>27:22</p></td>
<td class="confluenceTd"><p>13 de março de 2018</p></td>
</tr>
<tr class="odd">
<td class="confluenceTd"><p><a href="https://success.jitterbit.com/display/DOC/Open+API+Portal+Manager+Tech+Talk?showLanguage=pt_BR">Open API Portal Manager</a></p></td>
<td class="confluenceTd"><p>57:21</p></td>
<td class="confluenceTd"><p>05 de novembro de 2019</p></td>
</tr>
<tr class="even">
<td class="confluenceTd"><p><a href="https://success.jitterbit.com/display/DOC/Process+Templates+Tech+Talk?showLanguage=pt_BR"><em>Templates</em> de Processo</a></p></td>
<td class="confluenceTd"><p>43:27</p></td>
<td class="confluenceTd"><p>08 de julho de 2020</p></td>
</tr>
</tbody>
</table>

</div>

### Documentação

A documentação da Jitterbit tem melhores práticas inclusas com as nossas páginas sobre o uso da Jitterbit:

#### Segurança

-   **[*Whitepaper* da Segurança e Arquitetura Jitterbit](https://success.jitterbit.com/display/DOC/Jitterbit+Security+and+Architecture+White+Paper?showLanguage=pt_BR)**<br/>
    Uma descrição da segurança e arquitetura lógicas, segurança física e organizacional fornecidas pela plataforma do Jitterbit Harmony.

-   **[Melhores Práticas de Segurança para Administradores, Construtores de Projeto e Especialistas de Integração](https://success.jitterbit.com/display/DOC/Security+Best+Practices+for+Administrators%2C+Project+Builders%2C+and+Integration+Specialists?showLanguage=pt_BR)**<br/>
    Recomendações de segurança para quem integra o Jitterbit Harmony com outros produtos como Salesforce, NetSuite e outros *endpoints*.

#### Metodologia de Projeto de Integração

-   **[Metodologia de Projeto de Integração](https://success.jitterbit.com/display/DOC/Integration+Project+Methodology?showLanguage=pt_BR)**<br/>
    Este documento aborda os itens chave que um(a) Gerente de Projeto em um projeto do Jitterbit Harmony deve saber. Ele mostra como organizar a sua equipe, como reunir e validar requisitos de forma clara e concisa, e como usar bem os pontos fortes do Jitterbit Harmony para entregar um projeto de sucesso.

#### Criando Projetos

-   **[Melhores Práticas para SAP](https://success.jitterbit.com/display/DOC/Best+Practices+for+SAP?showLanguage=pt_BR)**<br/>
    Problemas e considerações que podem surgir ao integrar de e para instâncias SAP, principalmente ao se criar uma integração bidirecional.

-   **[Capturando Mudanças de Dados com Mudanças de Tabela ou Arquivo](https://success.jitterbit.com/display/DOC/Capturing+Data+Changes+with+Table+or+File+Changes?showLanguage=pt_BR)**<br/>
    Melhores práticas para seguir ao capturar mudanças de dados.

-   **[Configurando Mensagens de Saída com a API do Harmony](https://success.jitterbit.com/display/DOC/Configuring+Outbound+Messages+with+Harmony+API?showLanguage=pt_BR)**<br/>
    As abordagens recomendadas para configurar mensagens de saída.

-   **[Informação de Bancos de Dados Específicos](https://success.jitterbit.com/display/CS/Database-Specific+Information?showLanguage=pt_BR)**<br/>
    Melhores práticas para se conectar com vários bancos de dados.

-   **[Agendas de Operação](https://success.jitterbit.com/display/CS/Operation+Schedules?showLanguage=pt_BR)**<br/>
    Melhores práticas para seguir ao se criar e executar uma agenda.

-   **[Como Preparar Alertas, Registros e Tratamento de Erros](https://success.jitterbit.com/display/DOC/Setting+Up+Alerting%2C+Logging%2C+and+Error+Handling?showLanguage=pt_BR)**<br/>
    Melhores práticas para como alertar os usuários sobre problemas de integração.

-   **[Como Preparar um Projeto de Colaboração em Equipe](https://success.jitterbit.com/display/DOC/Setting+Up+a+Team+Collaboration+Project?showLanguage=pt_BR)**<br/>
    Melhores práticas para suportar vários desenvolvedores trabalhando no mesmo projeto.

#### Registros

-   **[Registro da Depuração de Operações](https://success.jitterbit.com/display/DOC/Operation+Debug+Logging?showLanguage=pt_BR)**<br/>
    Informações sobre como gerar dados de registro de operação adicionais.

-   **[Localizações dos Arquivos de Registros](https://success.jitterbit.com/display/DOC/Log+File+Locations?showLanguage=pt_BR)**<br/>
    As localizações dos arquivos de registros dos Private Agents.

-   **[Como Preparar Alertas, Registros e Tratamento de Erros](https://success.jitterbit.com/display/DOC/Setting+Up+Alerting%2C+Logging%2C+and+Error+Handling?showLanguage=pt_BR)**<br/>
    Melhores práticas para como alertar os usuários sobre problemas de integração.

#### Private Agents

-   **[Alta Disponibilidade e Balanceamento de Cargas de Agent Groups](https://success.jitterbit.com/display/DOC/Agent+Groups+High+Availability+and+Load+Balancing?showLanguage=pt_BR)**<br/>
    Recomendações que devem ser levadas em consideração antes da instalação de Private Agent(s) para permitir alta disponibilidade (ativo/ativo) e balanceamento de carga.

-   **[Requisitos de Sistema para Private Agents](https://success.jitterbit.com/display/DOC/System+Requirements+for+Private+Agents?showLanguage=pt_BR)**<br/>
    Melhores práticas ao criar, instalar e configurar um Private Agent.
    